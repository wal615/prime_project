---
title: "Reproduce proposal's results"
author: "Xuelong Wang"
date: "`r Sys.Date()`"
output: 
  html_document: 
    fig_caption: yes
    fig_width: 18
    keep_md: yes
    number_sections: yes
    theme: united
    toc: yes
---

```{r, include=FALSE}
knitr::opts_knit$set(root.dir = "~/dev/projects/Chen_environmental_study/")
options(width = 100)
library(ggplot2)
library(tidyverse)
library(sas7bdat)
library(printr)


#####################################################################################
## figures number function
#####################################################################################
# A function for captioning and referencing images
fig <- local({
    i <- 0
    ref <- list()
    list(
        cap=function(refName, text) {
            i <<- i + 1
            ref[[refName]] <<- i
            paste("Figure ", i, ": ", text, sep="")
        },
        ref=function(refName) {
            ref[[refName]]
        })
})

#####################################################################################
## figures number function
#####################################################################################
# A function for captioning and referencing tables

tab <- local({
    i <- 0
    ref <- list()
    list(
        cap=function(refName, text) {
            i <<- i + 1
            ref[[refName]] <<- i
            paste("Table ", i, ": ", text, sep="")
        },
        ref=function(refName) {
            ref[[refName]]
        })
})

#####################################################################################
## calculate MSE for the result 
#####################################################################################
sum_fn <- function(x) {
  x <- x[x[,1]!=0,]
  c(colMeans((x[,c(3,4)] -x[,c(1,2)])^2), colMeans((x[,c(5,6)] -x[,c(1,2)])^2))}

#####################################################################################
## plot function
#####################################################################################
# center all the title's
theme_update(plot.title = element_text(hjust = 0.5,size = 22, face = "bold")) 

plot_fn <- function(x, names) {
    x <- x[x[,1]!=0,]
    g1<- ggplot(tidyr::gather(data.frame(x[,c(1,3,5)])), aes(value, fill = key, y = ..density..)) +
    geom_histogram(alpha = 0.2, position = "identity", binwidth =  0.5) +
    geom_density(alpha = 0.2) +
    xlim(-10,20)+
    scale_fill_discrete(name="Methods",
                        labels=c("Original GCTA", "Proposed Method", "True value"))+
    theme(legend.title = element_text(size=16))+
    ggtitle(paste0("main_total_effect_",names))
  
    g2 <- ggplot(tidyr::gather(data.frame(x[,c(2,4,6)])), aes(value, fill = key, y = ..density..)) +
    geom_histogram(alpha = 0.2, position = "identity", binwidth =  0.5) +
    geom_density(alpha = 0.2) +
    xlim(0,20)+
    labs(fill="Methods")+
    ggtitle(paste0("interaction_total_effect_",names))
    
    gridExtra::grid.arrange(g1, g2, ncol=2)
}

box_plot_fn <- function(x, names){
  x <- x[x[,1]!=0,]
  g1 <- ggplot(tidyr::gather(data.frame(x[,c(1,3,5)])), aes(x = key, y = value, color = key)) + 
    geom_boxplot() +
    ylim(-10,20)+
    labs(color ="Methods")+
    labs(x = "method", y = "Variance")+
    ggtitle(paste0("main_total_effect_",names))
  
  g2 <- ggplot(tidyr::gather(data.frame(x[,c(2,4,6)])), aes(x = key, y = value, color = key)) + 
    geom_boxplot() +
    ylim(0, 20)+
    labs(color ="Methods")+
    labs(x = "method", y = "Variance")+
    ggtitle(paste0("interaction_total_effect_",names))
    
  gridExtra::grid.arrange(g1, g2, ncol=2)
}

```

# Reproduce the proposal's result with different $\beta's$ values

- The following 5 simulation situations are trying to mimic the results from the proposal. The only difference is that simulations runs on 50 different beta's values, so that we can have an overall evaluation of the proposed and original method.
- The covariates are transformed by their ranks.
- The core of my code generating the simuation results are also from the propsal.
- Based on the results of the first 4 situations, both methods work fine. It seems that the code can reproduce the results from the proposal. 
- At the last situation, we found that the proposed method seems have a even larger bias than the original GCTA method.


## Signal is generated by PCB data with no intercation (no intercation terms in the fitting model) 

```{r, echo=FALSE}
load("./result/simulation_result_reproduce_with_rep_beta")
source("./R_code/Yang_REML.R")

out_table <- t(sum_fn(result_list$PCB_no_inter_m))
rownames(out_table) <- "MSE"

knitr::kable(x = out_table, 
             row.names = TRUE,
             format = "html",
             caption = tab$cap("PCB_no_inter_m","MSE of estimated varaince with PCB data without intercation"))  %>% 
  kableExtra::kable_styling(full_width = FALSE)
```
- In the Table `r tab$ref('PCB_no_inter_m')`, "GCTA_main" and "GCTA_interaction" stands for the estimation of GCTA method. 
- "pro_main" and "pro_interaction" stand for the estimation of proposed method. 
- MSE is calculated by $\sum(\sigma^2_{estimation} - \sigma^2_{true})^2/n$
- n in our case is 50

```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("PCB_no_inter_m", "Box-plot of Main and Interaction variance with PCB data without intercation")}
  box_plot_fn(result_list$PCB_no_inter_m,"PCB_no_inter_m")
```

```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("PCB_no_inter_m", "Histogram of Main and Interaction variance with cox-box transformed data")}
  plot_fn(result_list$PCB_no_inter_m,"PCB_no_inter_m")
```


## Signal is generated by PCB data with no intercation (intercation terms in the fitting model) 

```{r, echo=FALSE}
out_table <- t(sum_fn(result_list$PCB_no_inter))
rownames(out_table) <- "MSE"

knitr::kable(x = out_table, 
             row.names = TRUE,
             format = "html",
             caption = tab$cap("PCB_no_inter","MSE of estimated varaince with PCB data without intercation"))  %>% 
  kableExtra::kable_styling(full_width = FALSE)
```


```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("PCB_no_inter", "Box-plot of Main and Interaction variance with PCB data without intercation")}
  box_plot_fn(result_list$PCB_no_inter,"PCB_no_inter")
```

```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("PCB_no_inter", "Histogram of Main and Interaction variance with cox-box transformed data")}
  plot_fn(result_list$PCB_no_inter,"PCB_no_inter")
```

## Signal is generated by covariates Simulated from an __uncorrelated__ Multivariate Normal distribution

- the covariate is generated by a normal distribution i.e. $x \sim N(0, I_p)$, where $p = 34$

```{r, echo=FALSE}
out_table <- t(sum_fn(result_list$b_norm_uncorr))
rownames(out_table) <- "MSE"

knitr::kable(x = out_table, 
             row.names = TRUE,
             format = "html",
             caption = tab$cap("b_norm_uncorr","MSE of estimated varaince with PCB data without intercation"))  %>% 
  kableExtra::kable_styling(full_width = FALSE)
```


```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("b_norm_uncorr", "Box-plot of Main and Interaction variance with PCB data without intercation")}
  box_plot_fn(result_list$b_norm_uncorr,"b_norm_uncorr")
```

```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("b_norm_uncorr", "Histogram of Main and Interaction variance with cox-box transformed data")}
  plot_fn(result_list$b_norm_uncorr,"b_norm_uncorr")
```

## Signal is generated by covariates Simulated from an __correlated__ Multivariate Normal distribution

- the covariate is generated by a normal distribution i.e. $x \sim N(0, \Sigma_p)$, where all un-diagonal elements of $\Sigma_p$ are equal to 2


```{r, echo=FALSE}
out_table <- t(sum_fn(result_list$b_norm_corr))
rownames(out_table) <- "MSE"

knitr::kable(x = out_table, 
             row.names = TRUE,
             format = "html",
             caption = tab$cap("b_norm_corr","MSE of estimated varaince with PCB data without intercation"))  %>% 
  kableExtra::kable_styling(full_width = FALSE)
```


```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("b_norm_corr", "Box-plot of Main and Interaction variance with PCB data without intercation")}
  box_plot_fn(result_list$b_norm_corr,"b_norm_corr")
```

```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("b_norm_corr", "Histogram of Main and Interaction variance with cox-box transformed data")}
  plot_fn(result_list$b_norm_corr,"b_norm_corr")
```

## Signal is generated by PCB data with __intercation__ 

```{r, echo=FALSE}
out_table <- t(sum_fn(result_list$PCB_with_inter))
rownames(out_table) <- "MSE"

knitr::kable(x = out_table, 
             row.names = TRUE,
             format = "html",
             caption = tab$cap("PCB_with_inter","MSE of estimated varaince with PCB data without intercation"))  %>% 
  kableExtra::kable_styling(full_width = FALSE)
```


```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("PCB_with_inter", "Box-plot of Main and Interaction variance with PCB data without intercation")}
  box_plot_fn(result_list$PCB_with_inter,"PCB_with_inter")
```

```{r , echo = FALSE, warning=FALSE, fig.cap=fig$cap("PCB_with_inter", "Histogram of Main and Interaction variance with cox-box transformed data")}
  plot_fn(result_list$PCB_with_inter,"PCB_with_inter")
```
